<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BRAG Allotment Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin: 0; padding: 1rem; font-family: system-ui, sans-serif; background: #f5f5f5; }
    .map-container { position: relative; background: #fff; border: 1px solid #ccc; overflow: auto; }
    .map-container svg { width: 100%; height: auto; display: block; }

    .tooltip {
      position: absolute;
      padding: 0.3rem 0.5rem;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-size: 0.85rem;
      border-radius: 4px;
      pointer-events: none;
      white-space: nowrap;
      display: none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <h1>BRAG Allotment Map</h1>
  <div class="map-container" id="mapContainer"></div>
  <div class="tooltip" id="tooltip"></div>

  <script>
    // --- Parse straight-edge SVG path (M/m, L/l, H/h, V/v, Z/z) into absolute points ---
    function pathToPoints(d) {
      // Tokenize commands + numbers
      const tokens = d
        .replace(/,/g, " ")
        .trim()
        .match(/[a-zA-Z]|[-+]?\d*\.?\d+(?:e[-+]?\d+)?/g);

      if (!tokens || tokens.length === 0) return null;

      let i = 0;
      let cmd = null;
      let x = 0, y = 0;
      let startX = 0, startY = 0;
      const pts = [];

      function readNumber() {
        const t = tokens[i++];
        if (t == null) throw new Error("Unexpected end of path data");
        const n = Number(t);
        if (!Number.isFinite(n)) throw new Error("Bad number: " + t);
        return n;
      }

      while (i < tokens.length) {
        const t = tokens[i];

        // command
        if (/^[a-zA-Z]$/.test(t)) {
          cmd = t;
          i++;
        } else if (!cmd) {
          // Path data must start with a command
          return null;
        }

        switch (cmd) {
          case "M":
          case "m": {
            const isRel = (cmd === "m");
            // first pair is move
            const nx = readNumber();
            const ny = readNumber();
            x = isRel ? x + nx : nx;
            y = isRel ? y + ny : ny;
            startX = x; startY = y;
            pts.push([x, y]);

            // any subsequent pairs are implicit "L/l"
            while (i < tokens.length && !/^[a-zA-Z]$/.test(tokens[i])) {
              const lx = readNumber();
              const ly = readNumber();
              x = isRel ? x + lx : lx;
              y = isRel ? y + ly : ly;
              pts.push([x, y]);
            }
            break;
          }

          case "L":
          case "l": {
            const isRel = (cmd === "l");
            while (i < tokens.length && !/^[a-zA-Z]$/.test(tokens[i])) {
              const lx = readNumber();
              const ly = readNumber();
              x = isRel ? x + lx : lx;
              y = isRel ? y + ly : ly;
              pts.push([x, y]);
            }
            break;
          }

          case "H":
          case "h": {
            const isRel = (cmd === "h");
            while (i < tokens.length && !/^[a-zA-Z]$/.test(tokens[i])) {
              const hx = readNumber();
              x = isRel ? x + hx : hx;
              pts.push([x, y]);
            }
            break;
          }

          case "V":
          case "v": {
            const isRel = (cmd === "v");
            while (i < tokens.length && !/^[a-zA-Z]$/.test(tokens[i])) {
              const vy = readNumber();
              y = isRel ? y + vy : vy;
              pts.push([x, y]);
            }
            break;
          }

          case "Z":
          case "z": {
            // close path: ensure it ends at start
            // (donâ€™t duplicate start point if already there)
            const last = pts[pts.length - 1];
            if (!last || last[0] !== startX || last[1] !== startY) {
              pts.push([startX, startY]);
            }
            break;
          }

          default:
            // Curves/arc not supported in this simple centroid method
            return null;
        }
      }

      // Remove duplicate last point if it equals first (for centroid formula convenience)
      if (pts.length > 2) {
        const a = pts[0], b = pts[pts.length - 1];
        if (a[0] === b[0] && a[1] === b[1]) pts.pop();
      }

      return pts.length >= 3 ? pts : null;
    }

    // --- Polygon centroid (works great for convex polygons, including triangles) ---
    function polygonCentroid(points) {
      let area2 = 0;   // 2 * area
      let cx = 0;
      let cy = 0;

      for (let i = 0; i < points.length; i++) {
        const [x0, y0] = points[i];
        const [x1, y1] = points[(i + 1) % points.length];
        const cross = x0 * y1 - x1 * y0;
        area2 += cross;
        cx += (x0 + x1) * cross;
        cy += (y0 + y1) * cross;
      }

      if (Math.abs(area2) < 1e-8) return null; // degenerate
      const area = area2 / 2;
      cx /= (6 * area);
      cy /= (6 * area);
      return { x: cx, y: cy, area: Math.abs(area) };
    }

    (async function () {
      const container = document.getElementById("mapContainer");
      const tooltip = document.getElementById("tooltip");

      // Load and inline the SVG
      const res = await fetch("BRAGMap.svg");
      if (!res.ok) {
        console.error("Failed to load BRAGMap.svg:", res.status);
        return;
      }
      container.innerHTML = await res.text();

      const svg = container.querySelector("svg");
      if (!svg) {
        console.error("No <svg> found in BRAGMap.svg");
        return;
      }

      // Find Plots layer by its Inkscape label (stable)
      const plotsLayer = svg.querySelector(
        "g[inkscape\\:groupmode='layer'][inkscape\\:label='Plots']"
      );
      if (!plotsLayer) {
        console.error("Plots layer not found (check inkscape:label='Plots')");
        return;
      }

      const plots = plotsLayer.querySelectorAll("path[inkscape\\:label]");
      console.log("Found plots:", plots.length);

      // Create labels group (top-most) and make it non-interactive
      const NS = "http://www.w3.org/2000/svg";
      let labelsGroup = svg.querySelector("#auto-labels");
      if (!labelsGroup) {
        labelsGroup = document.createElementNS(NS, "g");
        labelsGroup.setAttribute("id", "auto-labels");
        labelsGroup.setAttribute("pointer-events", "none");
        svg.appendChild(labelsGroup);
      } else {
        labelsGroup.innerHTML = "";
      }

      // Base label styling (can tweak later)
      labelsGroup.setAttribute("font-family", "system-ui, sans-serif");
      labelsGroup.setAttribute("fill", "#111");

      plots.forEach(plot => {
        const label = plot.getAttribute("inkscape:label");
        if (!label) return;

        // Compute centroid from vertices
        let x, y, size;

        const pts = pathToPoints(plot.getAttribute("d") || "");
        const centroid = pts ? polygonCentroid(pts) : null;

        if (centroid) {
          x = centroid.x;
          y = centroid.y;

          // Scale font to area gently (keeps triangles sane)
          // (tweak these numbers as you like)
          const s = Math.sqrt(centroid.area);
          size = Math.max(10, Math.min(18, Math.round(s * 0.12)));
        } else {
          // Fallback to bbox
          const bb = plot.getBBox();
          x = bb.x + bb.width / 2;
          y = bb.y + bb.height / 2;
          size = Math.max(10, Math.min(18, Math.round(Math.min(bb.width, bb.height) * 0.35)));
        }

        const text = document.createElementNS(NS, "text");
        text.textContent = label;
        text.setAttribute("x", String(x));
        text.setAttribute("y", String(y));
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("dominant-baseline", "middle");
        text.setAttribute("font-size", String(size));
        labelsGroup.appendChild(text);

        // Keep plot interactive for hover tooltip
        plot.style.pointerEvents = "all";

        plot.addEventListener("mouseenter", () => {
          tooltip.textContent = label;
          tooltip.style.display = "block";
        });
        plot.addEventListener("mousemove", e => {
          tooltip.style.left = e.pageX + 12 + "px";
          tooltip.style.top = e.pageY + 12 + "px";
        });
        plot.addEventListener("mouseleave", () => {
          tooltip.style.display = "none";
        });
      });
    })();
  </script>
</body>
</html>
